## Prepare matching intervals functions
## Main three: make_fusion_anno_table(), make_transcript_table(), make_matching_intervals()

get_metadata_starfusion = function(starfusion_file) {
  metadata=data.frame(stringsAsFactors=FALSE)
  for (line in readLines(starfusion_file)) { 
    if(grepl("version",line)) {
      version_str = str_split(line," ")[[1]]
      row=c()
      row$key = as.character(version_str[2])
      row$value = as.character(version_str[3])
      metadata$key  = as.character(metadata$key)
      metadata$value  = as.character(metadata$value)
      
      metadata = rbind(metadata,row)
    }
    if(!startsWith(line,"#")){
      break
    }
  }         
  
  return(metadata)
}

get_fusion_bp_distance = function(left,right){
  left = GRanges(left)
  right = GRanges(right)
  distance = GenomicRanges::distance(left,right, ignore.strand=T)
  return(distance)
} 

#needs global variable genes
make_fusion_anno_table = function(starfusion_file) {
  i=0
  for (line in readLines(starfusion_file)) { 
    i=i+1
    if(!startsWith(line,"#")){
      break
    }
  }         
  fusion_anno_table = read.csv(starfusion_file, skip = (i-2),header=T,sep="\t",stringsAsFactors=F)
  fusion_anno_table$identifier  = as.integer(rownames(fusion_anno_table)) #to match with fusion object generated by chimeraviz
  
  #add identifiers
  fusion_anno_table = fusion_anno_table %>% dplyr::rename(fusion_name = X.FusionName)
  fusion_anno_table$fusion_identifier = paste0(patient$patient_identifier,"_",fusion_anno_table$identifier)
  fusion_anno_table$patient_identifier = patient$patient_identifier
  
  #remove mitochondrial 
  fusion_anno_table=fusion_anno_table[!(grepl("chrM",fusion_anno_table$LeftBreakpoint)|grepl("chrM",fusion_anno_table$RightBreakpoint)),]
  
  #Gene annotation 
  fusion_anno_table = fusion_anno_table %>% 
    separate(col="LeftGene",into=c("left_gene_id","left_ensembl_id"),sep="\\^") %>%
    separate(col="RightGene",into=c("right_gene_id","right_ensembl_id"),sep="\\^")
  
  #fusion_anno_table$left_ensembl_id = remove_version_from_id(fusion_anno_table$left_ensembl_id)
  #fusion_anno_table$right_ensembl_id = remove_version_from_id(fusion_anno_table$right_ensembl_id)
  
  fusion_anno_table = fusion_anno_table %>%
    left_join(genes[,c("gene_id","gene_type")],by=c("left_ensembl_id"="gene_id")) %>% 
    rename(left_gene_type=gene_type) %>% 
    left_join(genes[,c("gene_id","gene_type")],by=c("right_ensembl_id"="gene_id")) %>%
    rename(right_gene_type=gene_type)
  
  # annotate fusion bp distance
  fusion_anno_table$fusion_bp_distance = mapply(get_fusion_bp_distance, fusion_anno_table$LeftBreakpoint, fusion_anno_table$RightBreakpoint)
  
  
  # Healthy chimera and cancer associated
  # use list in addition to SF annotation 
  fusion_anno_table = fusion_anno_table %>% mutate(anno_healthy_chimera = 
                                                     grepl("GTEx|BodyMap|DGD_PARALOGS|HGNC_GENEFAM|Greger_Normal|Babiceanu_Normal|ConjoinG",annots))
  
  fusion_anno_table = fusion_anno_table %>% mutate(anno_starfusion_cancer_db = 
                                                     grepl("Mitelman|chimer|Chimer|Cosmic|TCGA|FA_CancerSupp|Klijn_CellLines|HaasMedCancer|CCLE|TumorFusionsNAR2018|ArcherDX_panel|Onco|FoundationOne_panel",annots))
  
  return(fusion_anno_table)
}

#Note: assumes global variables transcripts,exons,introns,genes, and transcript_df 

make_matching_intervals = function(partner_gene,upstream,transcript_tbl){
  ## Make matching intervals
  # Consensus of multiple transcripts, to account for splicing differences and easier matching
  # 1) Adjacent intron to fusion bp
  # 2) Alternative splice junction according to StarFusion - match on bp in +- 10 range.
  # 3) Adjacent gene body, from breakpoint to start/end of gene - depending on whether up/down and strand
  # 4) Flanking interval: +/- 500 bp around breakpoint, subsetted to gene body if available. 
  
  #gene id column for ensembl id and make genomic ranges from the seqnames/start/end/strand
  row=c()
  gene = match_ensembl_gene(partner_gene,verbose=F) 
  gene_coordinates = GRanges()
  if(nrow(gene)==1) {
    gene_coordinates = GRanges(gene)
  } 
  
  tx_lst=transcript_tbl[transcript_tbl$upstream==upstream,c("transcript_id")]
  tx_introns= introns[names(introns) %in% tx_lst,]
  tx_exons = exons[names(exons) %in% tx_lst,]
    
  adjacent_intron = GenomicRanges::reduce(get_adjacent_intron(partner_gene,tx_introns,upstream))
  sjrange = GenomicRanges::reduce(subsetByOverlaps(sjdb_granges, flank(GRanges(partner_gene$sf_breakpoint),10,both = TRUE), ignore.strand=F))
  adjacent_genebody = GenomicRanges::reduce(get_adjacent_gene_body(partner_gene,tx_exons,upstream))
  flanking_interval = flank(GRanges(partner_gene$sf_breakpoint),500,both = TRUE)
  
  #subset to full gene to prevent going into to other genes and not validating this specific fusion 
  if(length(gene_coordinates)>0){
    #query, subject 
    flanking_interval = GenomicRanges::intersect(gene_coordinates,flanking_interval)
    sjrange = GenomicRanges::intersect(gene_coordinates,sjrange)
  }
  
  #store everything in row variable
  row$ensembl_used = ifelse(nrow(gene)>0,gene$gene_id,NA)
  row$gene_coordinates = gene_coordinates
  row$adjacent_intron =  adjacent_intron
  row$sjrange = sjrange
  row$flanking = flanking_interval
  row$adjacent_genebody = adjacent_genebody
  return(row)
}

make_transcript_table = function(partner_gene,upstream=TRUE){
  #input: gup/gdw from fusion object
  
  #Check if ensembl ID is found and matches location 
  #Note need ensembl id match to get transcripts, exons, introns and thus to make some of the matching intervals. 
  gene_match = match_ensembl_gene(partner_gene) 
  
  #Exit if no matching gene is found  
  if(nrow(gene_match)==0)
    return(data.frame())
  
  # Return transcripts and in specific where fusion bp is on exon-intron junction (exon boundary)
  ## Note that all tx are use as input for making intron and adjacent gene body 
  
  # ensembl id with version: gene_match$gene_id
  tx_lst = transcripts[grep(gene_match$gene_id,names(transcripts)),]
  tx_lst = tx_lst@unlistData$tx_name
  
  tx_introns= introns[names(introns) %in% tx_lst,]
  tx_exons= exons[names(exons) %in% tx_lst,]
  boundary_exons = tx_exons[is_bp_exon_boundary(partner_gene,tx_exons,upstream),] #transcripts with boundary exon.
  
  #start making tx dataframe
  tx_df = transcript_df %>% dplyr::filter(transcript_id %in% tx_lst) %>%
    dplyr::select(transcript_id,transcript_type,protein_id,transcript_support_level,tag,seqnames,start,end,strand)
  tx_df$transcript_coordinates =str_split(toString(GRanges(tx_df[,c("seqnames","start","end","strand")])),", ")[[1]]
  tx_df = tx_df[,!names(tx_df) %in% c("seqnames","start","end","strand")]
  tx_df = tx_df %>% dplyr::mutate(exon_boundary = transcript_id %in% names(boundary_exons))
  tx_df$upstream = upstream
  
  ## adjacent introns 
  adjacent_introns = get_adjacent_intron(partner_gene,tx_introns,upstream)
  if(length(adjacent_introns)>0) {
    adjacent_intron_df = as.data.frame(str_split(toString(adjacent_introns),", ")[[1]])
    colnames(adjacent_intron_df) = c("adjacent_intron")
    adjacent_intron_df$transcript_id = names(adjacent_introns)
    
    tx_df = tx_df %>% left_join(adjacent_intron_df, by = "transcript_id")
  } else {
    tx_df$adjacent_intron=NA
  }
  
  ## Involved fragment is similar to adjacent gene body but then opposite
  involved_fragment = get_involved_fragment(partner_gene,tx_exons,upstream)
  if(length(involved_fragment)>0) {
    involved_fragment_df = as.data.frame(str_split(toString(involved_fragment),", ")[[1]])
    colnames(involved_fragment_df) = c("involved_fragment")
    involved_fragment_df$transcript_id = names(involved_fragment)
    
    tx_df = tx_df %>% left_join(involved_fragment_df, by = "transcript_id")
  } else {
    tx_df$involved_fragment=NA
  }
  
  #get exon lead number last involved  so you can say exon X of Y
  # - strand exon lead number 1 has higher coordinate than last exon
  
  involved_exons = unlist(get_involved_exon(partner_gene,tx_exons,upstream))
  
  involved_exons_df = as.data.frame(names(involved_exons))
  colnames(involved_exons_df) = c("transcript_id")
  involved_exons_df$involved_exon = involved_exons$exon_rank
  
  tx_df = tx_df %>% left_join(involved_exons_df, by = "transcript_id")
  
  ##max exon per transcript 
  exon_rank_df = as.data.frame(names(unlist(tx_exons)))
  colnames(exon_rank_df) = c("transcript_id")
  exon_rank_df$exon_rank = unlist(tx_exons)$exon_rank
  
  exon_count_df = exon_rank_df %>% group_by(transcript_id) %>% summarize(max_exon = max(exon_rank),.groups="drop")
  
  tx_df = tx_df %>% left_join(exon_count_df, by = "transcript_id")
  
  
  ## involved fraction using tx interval and involved fragment
  tx_df[!is.na(tx_df$involved_fragment),c("involved_fragment_width")] = width(involved_fragment)
  tx_df$transcript_width = width(GRanges(tx_df$transcript_coordinates))
  
  tx_df$involved_fraction = NA
  tx_df[!is.na(tx_df$involved_fragment),c("involved_fraction")] = tx_df[!is.na(tx_df$involved_fragment),c("involved_fragment_width")]/tx_df[!is.na(tx_df$involved_fragment),c("transcript_width")]
  
  return(tx_df)  
}

## Helper functions
match_ensembl_gene = function(partner_gene,verbose=T) {
  ## Check if provided ensembl gene id matches reference
  ## Otherwise check for version mismatch
  ## Otherwise check breakpoint location 
  ## Note: can return multiple gene ids which are not used
  
  match_row = genes %>% dplyr::filter(grepl(partner_gene$ensembl_id,gene_id))
  if(nrow(match_row)==1) return(match_row)
  
  match_row = genes %>% dplyr::filter(grepl(remove_version_from_id(partner_gene$ensembl_id),gene_id))
  if(nrow(match_row)>0) {
    if(verbose) print(paste0("Warning version mismatch: (",partner_gene$gene_name,") ",partner_gene$ensembl_id," - instead using: ",match_row$gene_id))
    return(match_row)
  }
  
  match_location = subsetByOverlaps(gr_genes,GRanges(partner_gene$sf_breakpoint))
  
  if(length(match_location)>0) {
    match_row = as.data.frame(match_location)
    if(verbose) print(paste0("Warning ensembl_id mismatch: (",partner_gene$gene_name,") ",partner_gene$ensembl_id," - instead using: ",match_row$gene_id))
    return(match_row)
  }
  
  if(verbose) print(paste0("Warning missing ensembl_id, no location match found: (",partner_gene$gene_name,") ",partner_gene$ensembl_id," ",partner_gene$sf_breakpoint))
  return(data.frame())
}

is_bp_exon_boundary = function(partner_gene,transcript,upstream=TRUE){
  # up + = end; up - = start; down + = start; down - = end position
  #technically, transcript variable contains the exons of the transcript

  if( (upstream && partner_gene$forward_strand) | (!upstream && !partner_gene$forward_strand)) {
    return(any(end(transcript) == partner_gene$coordinate))
  } else {
    return(any(start(transcript) == partner_gene$coordinate))
  }
}

get_adjacent_intron = function(partner_gene,tx_introns,upstream=TRUE) {
  if( (upstream && partner_gene$forward_strand) | (!upstream && !partner_gene$forward_strand)) {
    #last of exon reported so match first of intron
    adjacent_introns = tx_introns[start(tx_introns)==partner_gene$coordinate+1]
  } else {
    #first of exon reported, so match last of intron 
    adjacent_introns =  tx_introns[end(tx_introns)==partner_gene$coordinate-1]
  }
  return(unlist(adjacent_introns))
  #unlist also removes the empty ones
}

get_involved_fragment= function(partner_gene,tx_exons,upstream=TRUE) {
  #opposite of adjacent gene body => switched the if 
  # 5 upstream + involved is lowest to bp / same for downstream - 
  # 3 downstream involved is bp to highest / same for upstream - 
  # + end of gene is highest, - start of gene is highest
  
  ## first subset to transcript names containg breakpoint
  # has to be done in two steps because we are filtering exons here and the tx names are just the labels
  tx_start_before_bp = names(unlist(tx_exons[start(tx_exons)<=partner_gene$coordinate]))
  tx_end_after_bp = names(unlist(tx_exons[end(tx_exons)>=partner_gene$coordinate]))
  tx_containing_bp = unique(intersect(tx_start_before_bp,tx_end_after_bp))
  tx_exons = tx_exons[tx_containing_bp]
  
 
  if (( upstream && partner_gene$forward_strand) || (!upstream && !partner_gene$forward_strand )){
    coordinate = min(start(tx_exons))
    coordinate = coordinate[coordinate<partner_gene$coordinate]
    if(length(coordinate)==0) return(GRanges())
    gene_fragment = GRanges(seqnames=partner_gene$chromosome, 
                            IRanges(start=coordinate,end=rep(partner_gene$coordinate,length(coordinate))),
                            strand=ifelse(partner_gene$forward_strand,"+","-")  )  
  } else {
    coordinate = max(end(tx_exons))
    coordinate = coordinate[coordinate>partner_gene$coordinate]
    if(length(coordinate)==0) return(GRanges())
    gene_fragment = GRanges(seqnames=partner_gene$chromosome, 
                            IRanges(start=rep(partner_gene$coordinate,length(coordinate)),end=coordinate),
                            strand=ifelse(partner_gene$forward_strand,"+","-")  )
  }
  names(gene_fragment)=names(coordinate)
  return(gene_fragment)
}

get_adjacent_gene_body = function(partner_gene,tx_exons,upstream=TRUE) {
  # 5 upstream adjacent interval bp to highest / same for downstream -
  # 3 downstream adjacent interval is bp to lowest / same for upstream - 
  # + end of gene is highest, - start of gene is highest
  
  if (( upstream && partner_gene$forward_strand) || (!upstream && !partner_gene$forward_strand )){
    coordinate = max(end(tx_exons))
    coordinate = coordinate[coordinate>partner_gene$coordinate]
    if(length(coordinate)==0) return(GRanges())
    gene_fragment = GRanges(seqnames=partner_gene$chromosome, 
                            IRanges(start=rep(partner_gene$coordinate,length(coordinate)),end=coordinate),
                            strand=ifelse(partner_gene$forward_strand,"+","-")  )
  } else {
    coordinate = min(start(tx_exons))
    coordinate = coordinate[coordinate<partner_gene$coordinate]
    if(length(coordinate)==0) return(GRanges())
    gene_fragment = GRanges(seqnames=partner_gene$chromosome, 
                            IRanges(start=coordinate,end=rep(partner_gene$coordinate,length(coordinate))),
                            strand=ifelse(partner_gene$forward_strand,"+","-")  )  
  }
  
  names(gene_fragment)=names(coordinate)
  
  return(gene_fragment)
}

get_involved_exon = function(partner_gene,tx_exons,upstream=TRUE) {
  if( (upstream && partner_gene$forward_strand) | (!upstream && !partner_gene$forward_strand)) {
    #last of exon reported 
    involved_exon = tx_exons[end(tx_exons)==partner_gene$coordinate]
  } else {
    #first of exon reported
    involved_exon =  tx_exons[start(tx_exons)==partner_gene$coordinate]
  }
  return(involved_exon)
}

